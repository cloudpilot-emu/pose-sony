/* -*- mode: C++; tab-width: 4 -*- */
/* ===================================================================== *\
	Copyright (c) 2001 Palm, Inc. or its subsidiaries.
	All rights reserved.

	This file is part of the Palm OS Emulator.

	This program is free software; you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation; either version 2 of the License, or
	(at your option) any later version.
\* ===================================================================== */

#include "EmCommon.h"
#include "EmMinimize.h"

#include "EmApplication.h"		// gApplication->ScheduleQuit
#include "EmDlg.h"				// MinimizeProgressOpen, DoCommonDialog
#include "EmEventPlayback.h"	// EnableEvents, DisableEvents
#include "EmSession.h"			// gSession
#include "Logging.h"			// LogAppendMsg
#include "ROMStubs.h"			// DmDatabaseInfo
#include "Startup.h"			// Startup::MinimizeQuitWhenDone

#include "ChunkFile.h"			// ChunkFile
#include "EmStreamFile.h"		// EmStreamFile
#include "SessionFile.h"		// SessionFile

#include <math.h>				// pow
#include <strstream>			// strstream

/*
	Minimization Overview

	A Gremlin run may terminate in error after any number of events.
	However, experience has shown that not all events created by the
	Gremlin are necessary to reproduce the error. Through minimization,
	the Palm OS Emulator attempts to find the minimal set of events that
	will cause an error. The use of "an" rather than "the" is
	intentional, as we can have no assurance that any error that occurs
	when intermediate events are cut out is the same error that
	initially occurred. The distinction is likely academic; what matters
	is that, given a file describing events that were generated by a
	Gremlin during a run, minimization will separate the wheat from the
	chaff, so to speak, by cutting out those events that do not
	contribute to the error.

	Theory

	Each event generated by a Gremlin can be viewed as a vertex in a
	directed graph. Each of these events relies on a particular context
	for its action to be relevant. For example, the first event relies
	on the root state to be loaded, and nothing else. The vertex or
	vertices that are responsible for bringing about a context (such as
	bringing up the Find dialog) have directed edges to all vertices
	representing actions within this context. If a particular vertex
	relies on no prior vertices for its context (the first vertex being
	a prime example), then the only vertex with an edge to it is the
	vertex representing the root state, which is noteworthy because it
	is the only vertex with no incoming edges.

	Viewed in this way, it becomes apparent that the problem of
	minimization is nothing more than finding the minimal set of
	vertices such that there is an unbroken string of directed edges
	between said vertices, and that the vertices representing the root
	state and the error-causing event are both within this set.

	In an alternate interpretation, events are once again vertices, and
	there are causal directed edges between events; the difference lies
	in that an edge is present iff the events represented by its
	endpoints are necessary to cause the error. Then the problem of
	minmization becomes a vertex cover problem: for reference, see:
	<http://www.cs.sunysb.edu/~algorith/files/vertex-cover.shtml>.

	Algorithm choice

	Vertex cover is an NP-complete problem, so it is not surprising that
	we cannot find a polynomial-time (in the number of events) algorithm
	to find the minimal set of events that will cause an error. Instead,
	I settle for an algorithm of order O(n^2 log n) -- in the worst
	case, it may have to make n log n passes, each O(n) because there
	are n events. This algorithm, while superficially resembling a
	divide-and-conquer algorithm, really is just a blind uninformed
	search algorithm that happens to narrow its scope by a factor of 2
	each time that it cuts out too many events. (Incidentally, I
	implemented a true divide-and-conquer algorithm as well, of nominal
	complexity O(n log n), which turned out to be slower on average than
	this algorithm, because of the sparse nature of this problem space
	since relatively few events typically contribute to an error.)

	One hard-coded limit worth mentioning is that once the range of
	events being removed from the set reaches a certain lower limit,
	events are handled in blocks, rather than being treated individually.
	This is done to soften the blow of the (necessarily) inefficient
	algorithm by artificially reducing n, by a factor identical to the
	block size.

	Event sequences are still minimized down to the individual event
	level, however, since minimization will continue, working off of the
	interim minimal event files that it saves. For example, a
	300-event run might be minimized to 30 events during the first run
	of minimization; the event file for these 30 events is saved
	automatically, and minimization is started anew on this 30-event
	run, ad inf.

	Implementation

	Since the structure of Palm OS Emulator does not allow for a
	recursive function that controls the entire process of minimization
	(as would ideally be the case), more novel means are used instead.
	As noted in the example below, the minimization process works by
	taking an event range, splitting it in two, and then testing each
	side to see if it is necessary for an error to occur.  If so, then
	we permanently disable that range of events and try the other half.
	But if the error did not occur, then we need to split the sub-range
	in two again and try again.

	The state for the process of splitting event ranges is stored in the
	fgState member.  This variable contains an fLevels member, which is
	a stack of event ranges.  The oldest item on the stack contains the
	entire event range.  The next items on the stack contain the left
	and right ranges after bisecting the initial range.  Each subsequent
	element on the stack is a further splitting of a range of the
	previous element.

	Example

	Let us imagine that we have a 8-event Gremlin run that terminates in
	an error that we wish to minimize. Of these 8 events, numbered
	0-indexed from 0-7, only events 0 and 7 are necessary. What these
	events actually are is inconsequential.

	This is the sequence of events that would transpire:

	LoadEvents would load the .pev file, initializing the event history
	vector. In New, a root minimizer node, whose span is the whole range
	of events (0-7) would be created. Since I make the (relatively safe)
	assumption that one cannot eliminate all of the events in a Gremlin
	run (save for the penultimate and ultimate events) and still hope to
	encounter the error, the root node's events are not turned off, and
	instead it spawns two children. These two child nodes cover the
	ranges (0-3) and (4-7), respectively. First the (0-3) node would be
	selected (this in New -- for all other selections, NextMinimizer is
	the locale), and events 0-3 turned off by setting minimizer (0-3)'s
	mask at indices {0, 1, 2, 3} to false. The mask at this point would
	look like this: f f f f t t t t. Since event 0 is necessary to
	reproduce the error, we would reach the bottom of PlaybackEvent, and
	Minimize would be called before NextMinimizer.

	In Minimize, (0-3) would have its events turned on, and then it
	would spawn two children of its own, (0-1) and (2-3). The event mask
	of its left child (0-1) at {0, 1} would then be unmasked (ie, the
	events would be replayed), and the left child (0-1) would be
	selected as the next minimizer to run. At this point the mask of
	minimizer (0-1) would look like this: f f t t t t t t. Again, we
	would not find the error, since event 0 would still not be replayed.
	The process would then be repeated, with the minimizer (0-1)
	spawning two child instances of (0-0) and (1-1). The left child of
	(0-1), (0-0) would be selected to run next. (0-0)'s mask would look
	like this: f t t t t t t t.

	This time, since we would be playing back all events except for 0,
	the run would again not terminate in error. At this point we will
	have hit our depth limit, so in Minimize, the events in the current
	minimizer's range (only event 0) would be turned on. Then, in
	NextMinimizer, (1-1) would be selected to run, after learning from
	its sibling node (0-0) that event 0 needs to be turned on. The mask
	of (1-1) at this point would look like this: t f t t t t t t. Its
	run would terminate in error, so from ErrorHandling::HandleDialog,
	NextMinimizer would be called, but not Minimize. This means that
	minimizer (1-1) will not spawn children of its own, even if the
	depth limit hadn't been reached, or have the events within its range
	turned back on. Instead, NextMinimizer will climb up the tree to
	(1-1)'s parent, (0-1). Before running (0-1), it will learn from its
	children (0-0) and (1-1) that event 0 is necessary but event 1 is
	not necessary to reproduce the error. Since (0-1) has already been
	run, it will not be run again -- at this point, its mask would look
	like this, for reference: t f t t t t t t. NextMinimizer would be
	invoked again, and since (0-1) is a left child, (2-3), its right
	sibling, would be the next minimizer to be run. Its events would be
	turned off after it absorbs the mask from its left sibling, (0-1).
	(2-3)'s mask would look like this: t f f f t t t t.

	Since events 0 and 7 are both turned on, this run would terminate in
	error. In NextMinimizer, since (2-3) is a right child, its parent,
	(0-3) would become the next minimizer. However, it has already been
	visited and run, so after assimilating the knowledge its children
	have gained (causing (0-3) to have a mask of t f f f t t t t), (4-7)
	would be run. When (4-7)'s events are turned off in
	TurnOffEventsInRange, event 7 would not be turned off, since I have
	hard-coded the assumption that it is not prudent to turn off the
	penultimate event (prior to the error). Thus, (4-7), after absorbing
	its left sibling's mask and having its events turned off (with the
	exception of event 7 as noted above), would have the mask of t f f f
	f f f t. This run would terminate in error, since events 0 and 7
	would be played back.

	In NextMinimizer (4-7) is seen to be a right sibling. However, its
	parent node is the root node of the binary tree, so it gets special
	treatment. The root node, after absorbing the masks of its children
	(0-3) and (4-7), gets marked as unvisited, so that it will be run,
	once. The root minimizer, with mask t f f f f f f t, is thus run
	once more, and its run terminates in error.

	Finally, in NextMinimizer again (via ErrorHandling::HandleDialog),
	minimization is turned off, and the event sequence is translated
	into English in OutputMinimalEvents.
*/

#if _DEBUG
#define LOG_MINIMIZATION	1
#else
#define LOG_MINIMIZATION	0
#endif

#define PRINTF	if (!LOG_MINIMIZATION) ; else LogAppendMsg

static const int	kMaxDepth			= 6;	// Split levels less than this.
static const int	kMinRange			= 1;	// Split ranges greater than this.
static const double	kReductionFactor	= 1.0;

omni_mutex					EmMinimize::fgMutex;
EmMinimize::EmMinimizeState	EmMinimize::fgState;
Bool						EmMinimize::fgIsOn;
uint32						EmMinimize::fgStartTime;
long						EmMinimize::fgInitialNumberOfEvents;
long						EmMinimize::fgDiscardedNumberOfEvents;
long						EmMinimize::fgMinRange;
long						EmMinimize::fgPassNumber;


static inline Bool PrvIsPenUp (const PointType& pt)
{
	return pt.x == -1 && pt.y == -1;
}

static inline Bool PrvIsPenDown (const PointType& pt)
{
	return !::PrvIsPenUp (pt);
}


#pragma mark -

// ---------------------------------------------------------------------------
//		¥ EmMinimize::Initialize
// ---------------------------------------------------------------------------

void EmMinimize::Initialize (void)
{
}


// ---------------------------------------------------------------------------
//		¥ EmMinimize::Reset
// ---------------------------------------------------------------------------

void EmMinimize::Reset (void)
{
	EmMinimize::TurnOn (false);
	fgState.fLevels.clear ();
}


// ---------------------------------------------------------------------------
//		¥ EmMinimize::Save
// ---------------------------------------------------------------------------

void EmMinimize::Save (SessionFile&)
{
}


// ---------------------------------------------------------------------------
//		¥ EmMinimize::Load
// ---------------------------------------------------------------------------

void EmMinimize::Load (SessionFile&)
{
}


// ---------------------------------------------------------------------------
//		¥ EmMinimize::Dispose
// ---------------------------------------------------------------------------

void EmMinimize::Dispose (void)
{
	EmMinimize::TurnOn (false);
	fgState.fLevels.clear ();
}


#pragma mark -

// ---------------------------------------------------------------------------
//		¥ EmMinimize::Start
// ---------------------------------------------------------------------------
// Startup the entire minimization process.  Called after a document is loaded
// with the intent of minimizaing the events stored with it.

void EmMinimize::Start (void)
{
	// Load the events.  Events are not loaded by default when the rest of
	// the session loads.  See comments for EmEventPlayback::Load ().

	EmMinimize::LoadEvents ();

	// Enable all events

	EmEventPlayback::EnableEvents ();

	// Check that this is a stream that ended in error.

	fgInitialNumberOfEvents = EmMinimize::FindFirstError ();
	if (fgInitialNumberOfEvents < 0)
	{
		EmDlg::DoCommonDialog ("Could not find an error.", kDlgFlags_OK);
		return;
	}

	// Initialize the minimization routines.

	fgStartTime					= Platform::GetMilliseconds ();
	fgDiscardedNumberOfEvents	= 0;
	fgPassNumber				= 1;

	EmMinimize::ComputeMinRange ();

	EmMinimize::TurnOn (true);
	EmMinimize::InitialLevel ();
	EmMinimize::SplitAndStartAgain ();

	// Open the progress dialog.

	EmDlg::MinimizeProgressOpen ();
}


// ---------------------------------------------------------------------------
//		¥ EmMinimize::Stop
// ---------------------------------------------------------------------------
// Stop the entire minimization process.  Called when the user presses the
// "Stop" button in the Minimization Control dialog.

void EmMinimize::Stop (void)
{
	EmMinimize::TurnOn (false);
	EmEventPlayback::ReplayEvents (false);
}


// ---------------------------------------------------------------------------
//		¥ EmMinimize::TurnOn
// ---------------------------------------------------------------------------

void EmMinimize::TurnOn (Bool newState)
{
	fgIsOn = newState;
}


// ---------------------------------------------------------------------------
//		¥ EmMinimize::IsOn
// ---------------------------------------------------------------------------

Bool EmMinimize::IsOn (void)
{
	return fgIsOn /* && EmEventPlayBack::ReplayingEvents () ? */;
}


#pragma mark -

// ---------------------------------------------------------------------------
//		¥ EmMinimize::NoErrorOccurred
// ---------------------------------------------------------------------------
// The current set of events were replayed with no error occurring.
// Therefore, we need to turn the most recent set of events back on, split
// it, and try again, as long as we're not too deep in the stack.

void EmMinimize::NoErrorOccurred (void)
{
	PRINTF ("EmMinimize::NoErrorOccurred:");

	// Turn current set of events back on.

	long	begin, end;
	EmMinimize::CurrentRange (begin, end);
	PRINTF ("EmMinimize::NoErrorOccurred: re-enabling events %ld - %ld.", begin, end);

	EmEventPlayback::EnableEvents (begin, end);

	// Split the current range and try again.

	EmMinimize::SplitAndStartAgain ();
}


// ---------------------------------------------------------------------------
//		¥ EmMinimize::ErrorOccurred
// ---------------------------------------------------------------------------
// The current set of events resulted in an error occurring.  Therefore, we
// can keep the current set of events turned off, and try to find others to
// turn off.

void EmMinimize::ErrorOccurred (void)
{
	PRINTF ("EmMinimize::ErrorOccurred:");

	// Keep the current set of events turned off.

	long	begin, end;
	EmMinimize::CurrentRange (begin, end);
	PRINTF ("EmMinimize::ErrorOccurred: discarding events %ld - %ld.", begin, end);

	fgDiscardedNumberOfEvents = fgInitialNumberOfEvents + 1 - EmEventPlayback::CountEnabledEvents ();

	// Pop the current range and try the next one.

	EmMinimize::NextSubRange (true);
}


#pragma mark -

uint32 EmMinimize::GetPassNumber (void)
{
	return fgPassNumber;
}


uint32 EmMinimize::GetElapsedTime (void)
{
	return Platform::GetMilliseconds () - fgStartTime;
}


void EmMinimize::GetCurrentRange (uint32& ubegin, uint32& uend)
{
	long	begin, end;
	EmMinimize::CurrentRange (begin, end);

	ubegin = begin;
	uend = end;
}


uint32 EmMinimize::GetNumDiscardedEvents (void)
{
	return fgDiscardedNumberOfEvents;
}


uint32 EmMinimize::GetNumInitialEvents (void)
{
	return fgInitialNumberOfEvents;
}


#pragma mark -

// ---------------------------------------------------------------------------
//		¥ EmMinimize::MinimizationPassComplete
// ---------------------------------------------------------------------------
// We've finished splitting and replaying events.  Examine the results to see
// if we're done, or if we need to make another Minimization passing using the
// remaining events.

void EmMinimize::MinimizationPassComplete (void)
{
	// Get the initial number of events, remove the masked-out events, and
	// then get the remaining number of events.

	long	oldNumEvents = EmEventPlayback::GetNumEvents ();

	EmEventPlayback::CullEvents ();
	EmMinimize::ComputeMinRange ();

	long	newNumEvents = EmEventPlayback::GetNumEvents ();

	// If significant culling occurred, then let's make another pass.

	if (EmMinimize::MakeAnotherPass (oldNumEvents, newNumEvents))
	{
		PRINTF ("EmMinimize::MinimizationPassComplete: making another pass.");
		PRINTF ("	oldNumEvents = %ld", oldNumEvents);
		PRINTF ("	newNumEvents = %ld", newNumEvents);

		++fgPassNumber;

		EmMinimize::InitialLevel ();
		EmMinimize::SplitAndStartAgain ();
	}

	// Otherwise, we are done!

	else
	{
		PRINTF ("EmMinimize::MinimizationPassComplete: DONE.");
		PRINTF ("	oldNumEvents = %ld", oldNumEvents);
		PRINTF ("	newNumEvents = %ld", newNumEvents);

		EmMinimize::MinimizationComplete ();
	}
}


// ---------------------------------------------------------------------------
//		¥ EmMinimize::MinimizationComplete
// ---------------------------------------------------------------------------
// Minimization is completely done.  Save the results, write out a text
// version of the events, and tell the user.

void EmMinimize::MinimizationComplete (void)
{
	PRINTF ("EmMinimize::MinimizationComplete: DONE.");

	// Stop the presses.

	EmMinimize::TurnOn (false);
	EmEventPlayback::ReplayEvents (false);

	// Save the minimal set of events.

	EmMinimize::SaveMinimalEvents ();

	// Convert the events to an English description.

	EmMinimize::OutputEventsAsEnglish ();

	// Reset to our initial state (as opposed to the error state we're
	// currently in).

	EmMinimize::LoadInitialState ();

	if (Startup::MinimizeQuitWhenDone ())
	{
		gApplication->ScheduleQuit ();
	}
	else
	{
		// Show a dialog telling the user about the results.

		char buffer[200];
		sprintf (buffer, "Minimization has been completed. %ld of %ld events discarded.",
			fgDiscardedNumberOfEvents, fgInitialNumberOfEvents);

		EmDlg::DoCommonDialog (buffer, kDlgFlags_OK);
	}
}


// ---------------------------------------------------------------------------
//		¥ EmMinimize::SaveMinimalEvents
// ---------------------------------------------------------------------------

void EmMinimize::SaveMinimalEvents (void)
{
	// Get the original event file.  We'll save the events in the same
	// directory but with a modified name.

	EmFileRef		oldEventRef = gSession->GetFile ();
	string			oldEventName = oldEventRef.GetName ();

	// Convert the name from <Foo>.pev to <Foo>_Min.pev.

	string			newEventName = oldEventName;

	if (::EndsWith (newEventName.c_str (), ".pev"))
	{
		newEventName = newEventName.substr (0, newEventName.size () - 4);
	}

	newEventName += "_Min.pev";

	// Copy the old session file to the new one that will hold the
	// minimized event set.

	EmFileRef		newEventRef (oldEventRef.GetParent (), newEventName);

	EmStreamFile	oldEventStream (oldEventRef, kOpenExistingForRead,
						kFileCreatorEmulator, kFileTypeEvents);
	EmStreamFile	newEventStream (newEventRef, kCreateOrEraseForWrite,
						kFileCreatorEmulator, kFileTypeEvents);

	ChunkFile		oldEventChunkFile (oldEventStream);
	ChunkFile		newEventChunkFile (newEventStream);

	int				index = 0;
	ChunkFile::Tag	tag;
	Chunk			chunk;

	while (oldEventChunkFile.ReadChunk (index, tag, chunk))
	{
		// Copy all chunks except the previous (pre-minimized)
		// event set.  We'll be adding the minimized event set
		// to the file later.

		if (tag != /*SessionFile::kGremlinHistory*/ 'hist')
		{
			newEventChunkFile.WriteChunk (tag, chunk);
		}

		++index;
	}

	// Now write the final event set.

	SessionFile		newEventSessionFile (newEventChunkFile);
	EmEventPlayback::SaveEvents (newEventSessionFile);
}


// ---------------------------------------------------------------------------
//		¥ EmMinimize::OutputEventsAsEnglish
// ---------------------------------------------------------------------------

void EmMinimize::OutputEventsAsEnglish (void)
{
	EmEventPlayback::LogEvents ();

	// Create a string stream to which we will write out results.  After
	// we completely buffer the output, we'll write it to a file.  We don't
	// write directly to the file so that we can take advantage of the
	// integer-to-text conversion facilities of ostream.

	strstream	stream;
#if 0
	// Get the event set.

	GremlinEventList	events;
	EmEventPlayback::GetEvents (events);

	// Write out our initial message.

	EmFileRef	ref = gSession->GetFile ();
	string		path = ref.GetFullPath ();

	stream << "=== Minimal Events:" << endl;
	stream << "0. Load " << path << endl;

	// Iterate over all the events.

	GremlinEventList::iterator	iter (events.begin ());

	while (iter != events.end ())
	{
		int	counter = iter - events.begin () + 1;

		stream << counter << ". ";

		switch (iter->eType)
		{
			case kGremlinKeyEvent:
			{
				uint16	ascii		= iter->data.keyEvent.ascii;
				uint16	keycode		= iter->data.keyEvent.keycode;
				uint16	modifiers	= iter->data.keyEvent.modifiers;
				string	charString	= EmMinimize::CharToString (ascii);

				if (keycode || modifiers)
				{
					stream
						<< "Enter character " << charString
						<< " with modifiers " << modifiers << endl;
				}
				else
				{
					stream
						<< "Enter character " << charString << endl;
				}

				break;
			}

			case kGremlinPenEvent:
			{
				PointType		pen			= iter->data.penEvent.coords;
				string			text		= iter->text;

				if (::PrvIsPenDown (pen))
				{
					if (text.empty ())
					{
						stream
							<< "Tap at " << pen.x << ", " << pen.y << endl;
					}
					else
					{
						stream
							<< "Tap on " << text
							<< " at " << pen.x << ", " << pen.y << endl;
					}
				}
				else
				{
					stream << "Lift stylus" << endl;
				}

				break;
			}

			case kGremlinAppSwitchEvent:
			{
				uint16	cardNo		= iter->data.appSwitchEvent.cardNo;
				uint32	dbID		= iter->data.appSwitchEvent.dbID;
				uint16	oldCardNo	= iter->data.appSwitchEvent.oldCardNo;
				uint32	oldDbID		= iter->data.appSwitchEvent.oldDbID;

				char	name [dmDBNameLength]		= { 0 };
				char	oldName [dmDBNameLength]	= { 0 };

				#define GET_NAME(x) x, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL

				::DmDatabaseInfo (cardNo, dbID, GET_NAME(name));
				::DmDatabaseInfo (oldCardNo, oldDbID, GET_NAME(oldName));

				if (strcmp (name, oldName) != 0)
				{
					stream
						<< "Switch to app \"" << name
						<< "\" from app \"" << oldName << "\"" << endl;
				}
				else
				{
					stream
						<< "Relaunch app \"" << name << "\"" << endl;
				}

				break;
			}

			case kGremlinNullEvent:
			{
				stream << "Idle event" << endl;

				break;
			}

			case kGremlinErrorEvent:
			{
				string err = Hordes::TranslateErrorCode (iter->data.errorEvent.errorType);

				stream << "App crashes with error " << err << endl;

				break;
			}

			default:
			{
				stream << "Unknown event" << endl;

				EmAssert (false);
			}
		}

		++iter;
	}

	stream << "=== Event listing complete." << endl;

	// Get the original event file.  We'll save the events in the same
	// directory but with a modified name.

	// Convert the name from <Foo>.pev to <Foo>_Min.pev.

	string			textEventName = ref.GetName ();

	if (::EndsWith (textEventName.c_str (), ".pev"))
	{
		textEventName = textEventName.substr (0, textEventName.size () - 4);
	}

	textEventName += "_Min.txt";

	// Create the output file.

	EmFileRef		textEventRef (ref.GetParent (), textEventName);
	EmStreamFile	textEventStream (textEventRef, kCreateOrEraseForWrite | kOpenText,
						kFileCreatorCodeWarrior, kFileTypeText);

	// Write the event text to it.

	textEventStream.PutBytes (stream.str (), stream.pcount ());

	// Unfreeze the stream, or else its storage will be leaked.

	stream.freeze (false);
#endif
}


// ---------------------------------------------------------------------------
//		¥ EmMinimize::MakeAnotherPass
// ---------------------------------------------------------------------------
// Return whether or not we feel that a significant amount of event culling
// had occurred in the pass.  If so, we'll want to make another pass.

Bool EmMinimize::MakeAnotherPass (long oldNumEvents, long newNumEvents)
{
	// Make another pass if we've reduced the number of events in the
	// previous pass by more than 10%.

	return newNumEvents < (oldNumEvents * kReductionFactor);
}


// ---------------------------------------------------------------------------
//		¥ EmMinimize::CurrentRange
// ---------------------------------------------------------------------------
// Return the current event range that we are examining.

void EmMinimize::CurrentRange (long& begin, long& end)
{
	omni_mutex_lock	lock (fgMutex);

	if (fgState.fLevels.size () > 0)
	{
		begin	= fgState.fLevels.back ().fBegin;
		end		= fgState.fLevels.back ().fEnd;
	}
	else
	{
		begin	= 0;
		end		= 0;
	}
}


// ---------------------------------------------------------------------------
//		¥ EmMinimize::InitialLevel
// ---------------------------------------------------------------------------
// Set up our "fLevels" member with the initial left/right event sub-ranges.

void EmMinimize::InitialLevel (void)
{
	EmAssert (fgState.fLevels.size () == 0);

	// Find the first error event (there may be more than one if several
	// non-fatal error events were inserted into the stream before a
	// terminating fatal one, or the non-fatal termination of the Gremlin).

	long	firstErrorEvent = EmMinimize::FindFirstError ();

	// We should be guaranteed to have one because we checked for that
	// in EmMinimize::Start.

	EmAssert (firstErrorEvent >= 0);

	// Turn off all events past the one causing the error.  Cull the
	// trailing events, too, so that our progress dialog doesn't
	// indicate they are there when it fetches the full number of events.

	if (firstErrorEvent + 1 < EmEventPlayback::GetNumEvents ())
	{
		EmEventPlayback::DisableEvents (firstErrorEvent + 1,
									EmEventPlayback::GetNumEvents ());
		EmEventPlayback::CullEvents ();
	}

	// Establish the initial event range.

	EmMinimizeLevel	newLevel;

	newLevel.fBegin		= 0;
	newLevel.fEnd		= firstErrorEvent;

	omni_mutex_lock	lock (fgMutex);

	fgState.fLevels.push_back (newLevel);

#if LOG_MINIMIZATION
	{
		PRINTF ("EmMinimize::InitialLevel: Added first level.");

		vector<EmMinimizeLevel>::iterator	iter = fgState.fLevels.begin ();

		while (iter != fgState.fLevels.end ())
		{
			PRINTF ("	%ld:", iter - fgState.fLevels.begin ());
			PRINTF ("		fBegin:    %ld", iter->fBegin);
			PRINTF ("		fEnd:      %ld", iter->fEnd);

			++iter;
		}
	}
#endif
}


// ---------------------------------------------------------------------------
//		¥ EmMinimize::SplitCurrentLevel
// ---------------------------------------------------------------------------
// Create a new level based on the given range.  The given range is split in
// two, records are created holding those two sub-ranges, and the records are
// pushed onto our stack.  Returns false if it was unable to create the two
// new ranges (either because the current range is too narrow or too deep).

Bool EmMinimize::SplitCurrentLevel (void)
{
	omni_mutex_lock	lock (fgMutex);

	long	begin	= fgState.fLevels.back ().fBegin;
	long	end		= fgState.fLevels.back ().fEnd;

	// Determine if we've reached the limit of exploration for this set
	// of events. If we have a ton of events, we don't want to search
	// at too fine grain of a level.  Therefore, split the event
	// ranges only so many times before we decide we've had enough.  In
	// order to process events at a finer grain, we will later examine
	// the results after a complete Minimization pass, and queue up
	// another pass with the remaining events if it looks like we'll
	// benefit from that.
	//
	// As well, we don't want to dice up event sub-ranges too small no
	// matter how many total events we're examining.  For instance, we
	// don't want to keep dividing if we're already examining a range
	// of 1 event!  For now, we'll set that threshold at 4 events.

	if (((end - begin) > fgMinRange))
	{
		long	midpoint = (begin + end) / 2;

		EmAssert (begin < midpoint);
		EmAssert (midpoint < end);

		// Remove the current record so that we can replace it with
		// two more that span the same range.

		fgState.fLevels.pop_back ();

		EmMinimizeLevel	newLevel;

		newLevel.fBegin		= midpoint;
		newLevel.fEnd		= end;

		fgState.fLevels.push_back (newLevel);

		newLevel.fBegin		= begin;
		newLevel.fEnd		= midpoint;

		fgState.fLevels.push_back (newLevel);

		PRINTF ("EmMinimize::SplitCurrentLevel: Added new level.");

#if LOG_MINIMIZATION
		{
			vector<EmMinimizeLevel>::iterator	iter = fgState.fLevels.begin ();

			while (iter != fgState.fLevels.end ())
			{
				PRINTF ("	%ld:", iter - fgState.fLevels.begin ());
				PRINTF ("		fBegin:    %ld", iter->fBegin);
				PRINTF ("		fEnd:      %ld", iter->fEnd);

				++iter;
			}
		}
#endif

		return true;
	}

	return false;
}


// ---------------------------------------------------------------------------
//		¥ EmMinimize::StartAgain
// ---------------------------------------------------------------------------
// Queue things up to start again.  Start the playback mechanism, and reload
// the initial state.

void EmMinimize::StartAgain (void)
{
	PRINTF ("EmMinimize::StartAgain: starting over.");

	EmEventPlayback::ReplayEvents (true);
	EmMinimize::LoadInitialState ();

	LogDump ();
}


// ---------------------------------------------------------------------------
//		¥ EmMinimize::SplitAndStartAgain
// ---------------------------------------------------------------------------
// Queue things up to start again.  Start the playback mechanism, and reload
// the initial state.

void EmMinimize::SplitAndStartAgain (void)
{
	// Try to split the range.  We may not be able to do that if the range
	// is too narrow or we've split too many times already.

	if (EmMinimize::SplitCurrentLevel ())
	{
		PRINTF ("EmMinimize::SplitAndStartAgain: split current range.");

		// Turn off the events in the (new) current sub-range.

		long	begin, end;
		EmMinimize::CurrentRange (begin, end);

		PRINTF ("EmMinimize::SplitAndStartAgain: disabling events %ld - %ld.", begin, end);

		EmEventPlayback::DisableEvents (begin, end);

		// Start again.

		EmMinimize::StartAgain ();
	}
	else
	{
		// We weren't able to split the current event range.  So pop
		// the current range off and work with its parent. 

		long	begin, end;
		EmMinimize::CurrentRange (begin, end);

		PRINTF ("EmMinimize::SplitAndStartAgain: too deep or narrow -- moving along.");
		PRINTF ("	begin = %ld", begin);
		PRINTF ("	end =   %ld", end);

		EmMinimize::NextSubRange (false);
	}
}


// ---------------------------------------------------------------------------
//		¥ EmMinimize::NextSubRange
// ---------------------------------------------------------------------------
// Pop an event range off of the stack and start working with the previous
// range that's now on the top of the stack.
//
// We can want to pop off a range for a couple of reasons: we've tested it and
// found that it's not needed to cause an error, so we no longer need to
// explore it, or we're reach some minimal event range threshhold and have
// decided not to sub-divide into any smaller ranges for this pass.
//
// Either way, we want to examine another range.  However, let's assume the
// following stack:
//
//		8-16
//		4-8
//		0-4
//
// Let's say we're popping off the 0-4 range because we just tested it and
// didn't find a crash.  If so, then we know that we know that something in
// 4-8 is required to cause the crash (why? because we already tested 0-8
// before sub-dividing it into 0-4 and 4-8).  Therefore we don't need to test
// 4-8 in toto.  Instead, we can proceed to sub-divide it immediately.
//
// On the other hand, say that we tested 0-4, found that the crash occurred,
// but are not sub-dividing it because our current event range threshhold
// is 4 events.  Therefore, we pop it off and move to 4-8.  This time, we
// don't want to sub-divide it.  This range is unknown: it may or may not
// be required to cause the crash.  So we need to test it.  And in testing it,
// we don't want to blindly sub-divide it first.  Remember that the event
// range threshhold is 4 in this example. so attempting to sub-divide the
// range would fail, and we'd end up popping off the 4-8 range as well before
// it was tested.
//
// The "forceSplit" parameter passed to this function distinguishes between
// these two cases.

void EmMinimize::NextSubRange (Bool forceSplit)
{
	{
		omni_mutex_lock	lock (fgMutex);

		PRINTF ("EmMinimize::NextSubRange: popping a level.");

		EmAssert (fgState.fLevels.size () > 0);

		fgState.fLevels.pop_back ();
	}

	// If there are no more ranges, we are done with this pass.
	// Check the results to see if we'd like to make another pass.

	if (fgState.fLevels.size () == 0)
	{
		EmMinimize::MinimizationPassComplete ();
		return;
	}


	if (forceSplit)
	{
		EmMinimize::SplitAndStartAgain ();
	}
	else
	{
		// Turn off the events in the (new) current sub-range.

		long	begin, end;
		EmMinimize::CurrentRange (begin, end);

		PRINTF ("EmMinimize::NextSubRange: disenabling events %ld - %ld.", begin, end);

		EmEventPlayback::DisableEvents (begin, end);

		// Start again.

		EmMinimize::StartAgain ();
	}
}


// ---------------------------------------------------------------------------
//		¥ EmMinimize::ComputeMinRange
// ---------------------------------------------------------------------------
// Determine the minimum range of events we'll consider during this pass.
// When dealing with lots of events, we don't necessarily want to examine
// event ranges down to the one and two level.  For the initial passes, we'll
// deal with only large clumps of events.  Later, once we've gotten the
// number of events down to size, we'll examine them at a smaller granularity.
// The following function sets the minumum number of events to:
//
//		(number of events) / (2 ^ kFactor)
//
// kFactor is chosen to give use good performance with a large number of
// events, eventually allowing us to examine events one at a time once
// we get down to some manageable level.  It's currently set to 6, allowing
// us to examine individual events once we reduce the total number of
// events down to 128.

void EmMinimize::ComputeMinRange (void)
{
	long	numEvents = EmEventPlayback::GetNumEvents ();

	fgMinRange = (long) (numEvents / pow (2, kMaxDepth));

	// Pin our minimum range to the absolute limit specified in kMinRange.
	// This is currently set to 1, which says not to split ranges that
	// are 1 or less.

	if (fgMinRange < kMinRange)
	{
		fgMinRange = kMinRange;
	}
}


// ---------------------------------------------------------------------------
//		¥ EmMinimize::LoadInitialState
// ---------------------------------------------------------------------------
// Reload the current file so that we can start pelting it with events again.

void EmMinimize::LoadInitialState (void)
{
	// Queue up a call to RealLoadInitialState.

	gSession->ScheduleMinimizeLoadState ();
}


// ---------------------------------------------------------------------------
//		¥ EmMinimize::RealLoadInitialState
// ---------------------------------------------------------------------------
// Reload the current file so that we can start pelting it with events again.

void EmMinimize::RealLoadInitialState (void)
{
	ErrCode result = errNone;

	try
	{
		EmAssert (gSession);
		gSession->Load (gSession->GetFile ());

		PRINTF ("EmMinimize::RealLoadInitialState: Reloaded initial state.");
	}
	catch (ErrCode errCode)
	{
		result = errCode;
	}

//	return result;
}


// ---------------------------------------------------------------------------
//		¥ EmMinimize::LoadEvents
// ---------------------------------------------------------------------------

void EmMinimize::LoadEvents (void)
{
	EmAssert (gSession);

	EmEventPlayback::LoadEvents (gSession->GetFile ());

	PRINTF ("EmMinimize::LoadEvents: loaded %d events.", EmEventPlayback::GetNumEvents ());
}


// ---------------------------------------------------------------------------
//		¥ EmMinimize::CharToString
// ---------------------------------------------------------------------------

string EmMinimize::CharToString (char theChar)
{
	string theString;

	switch (theChar)
	{
		case 10:

			theString = "<new line>";

			break;

		case 13:

			theString = "<carriage return>";

			break;

		case 27:

			theString = "<escape>";

			break;

		case 32:

			theString = "<space>";

			break;

		default:

			if ((theChar >= 0) && isprint (theChar))
			{
				theString = string (1, theChar);
				theString = "\"" + theString + "\"";
			}
			else
			{
				char	recp [6];

				sprintf (recp, "%03d", (uint8) theChar);
				theString = string (recp);
				theString = "<" + theString + ">";
			}

			break;
	}

	return theString;
}


// ---------------------------------------------------------------------------
//		¥ EmMinimize::FindFirstError
// ---------------------------------------------------------------------------
// Return the index of the first error event record.  Return -1 if one could
// not be found.
//
// Note: this routine is massively inefficient.  It iterates over all events
// starting from the beginning.  To do so, it calls EmEventPlayback::GetEvent,
// which also iterates all events from the beginning.  Therefore, if the
// error record is at index N, this loop will iterate over (N)(N-1)/2
// event records.

long EmMinimize::FindFirstError (void)
{
	EmRecordedEvent	event;
	long			numEvents = EmEventPlayback::GetNumEvents ();

	for (long ii = 0; ii < numEvents; ++ii)
	{
		EmEventPlayback::GetEvent (ii, event);

		if (event.eType == kRecordedErrorEvent)
		{
			PRINTF ("EmMinimize::FindFirstError: found an error event.");
			return ii;
		}
	}

	PRINTF ("EmMinimize::FindFirstError: failed to find an error event.");
	return -1;
}
